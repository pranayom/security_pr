"""Vulnerability scanner â€” regex-based pattern matching against source files."""

from pathlib import Path

from oss_maintainer_toolkit.config import settings
from oss_maintainer_toolkit.models import Severity, ScanResult, VulnerabilityFinding
from oss_maintainer_toolkit.scanners.patterns import PATTERNS


def scan_file(file_path: Path) -> list[VulnerabilityFinding]:
    """Scan a single file for vulnerability patterns."""
    findings: list[VulnerabilityFinding] = []
    suffix = file_path.suffix.lower()

    applicable_patterns = [
        p for p in PATTERNS
        if not p.languages or suffix in p.languages
    ]
    if not applicable_patterns:
        return findings

    try:
        content = file_path.read_text(encoding="utf-8", errors="replace")
    except (OSError, PermissionError):
        return findings

    for line_num, line in enumerate(content.splitlines(), start=1):
        for pat in applicable_patterns:
            if pat.pattern.search(line):
                findings.append(VulnerabilityFinding(
                    file=str(file_path),
                    line=line_num,
                    severity=Severity(pat.severity),
                    category=pat.category,
                    pattern_name=pat.name,
                    matched_text=line.strip(),
                    description=pat.description,
                ))

    return findings


def scan_vulnerabilities(target: str) -> ScanResult:
    """Scan a file or directory for vulnerabilities.

    Args:
        target: Path to a file or directory to scan.

    Returns:
        ScanResult with all findings.
    """
    target_path = Path(target)
    findings: list[VulnerabilityFinding] = []
    files_scanned = 0
    errors: list[str] = []
    max_size = settings.max_file_size_kb * 1024

    if target_path.is_file():
        files_to_scan = [target_path]
    elif target_path.is_dir():
        files_to_scan = [
            f for f in target_path.rglob("*")
            if f.is_file()
            and f.suffix.lower() in settings.scan_extensions
            and f.stat().st_size <= max_size
        ]
    else:
        return ScanResult(
            files_scanned=0,
            total_findings=0,
            findings=[],
            errors=[f"Target not found: {target}"],
        )

    for file_path in sorted(files_to_scan):
        try:
            file_findings = scan_file(file_path)
            findings.extend(file_findings)
            files_scanned += 1
        except Exception as e:
            errors.append(f"Error scanning {file_path}: {e}")

    return ScanResult(
        files_scanned=files_scanned,
        total_findings=len(findings),
        findings=findings,
        errors=errors,
    )
